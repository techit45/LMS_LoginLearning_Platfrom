import { useState, useEffect, useCallback, useRef, useMemo } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { calcomSchedulingService } from '../lib/calcomSchedulingService';
import { useToast } from './use-toast';

/**
 * Custom hook for Cal.com pure scheduling system
 * ‡πÉ‡∏ä‡πâ‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏°
 */
export const useCalcomSchedule = (currentWeek, company = null) => {
  const { user } = useAuth();
  const { toast } = useToast();
  
  // State management
  const [schedules, setSchedules] = useState({});
  const [courses, setCourses] = useState([]);
  const [instructors, setInstructors] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [isInitialized, setIsInitialized] = useState(false);
  const [syncLogs, setSyncLogs] = useState([]);
  const [calcomStatus, setCalcomStatus] = useState({
    initialized: false,
    connected: false,
    lastSync: null,
    syncInProgress: false
  });
  
  // Refs
  const currentWeekRef = useRef(currentWeek);
  
  // Calculate week start date - memoize to prevent re-creation
  const weekStartDate = useMemo(() => {
    return calcomSchedulingService.getWeekStartDate(currentWeek);
  }, [currentWeek]);

  /**
   * Initialize Cal.com scheduling system
   */
  const initializeSystem = useCallback(async () => {
    // Prevent re-initialization
    if (isInitialized) {
      console.log('‚è© Cal.com system already initialized, skipping...');
      return { success: true };
    }
    
    try {
      console.log('üöÄ Initializing Cal.com scheduling system...');
      setLoading(true);
      
      const result = await calcomSchedulingService.initialize();
      
      setCalcomStatus({
        initialized: result.success,
        connected: result.success,
        lastSync: result.data?.lastSync,
        syncInProgress: false
      });
      
      if (result.success) {
        setIsInitialized(true);
        console.log('‚úÖ Cal.com scheduling system initialized');
        
        toast({
          title: "‡∏£‡∏∞‡∏ö‡∏ö Cal.com ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÅ‡∏•‡πâ‡∏ß",
          description: "‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Cal.com API ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
          variant: "default"
        });
      } else {
        throw new Error(result.error);
      }
      
      return result;
    } catch (error) {
      console.error('üí• Cal.com system initialization failed:', error);
      setError(error.message);
      
      setCalcomStatus({
        initialized: false,
        connected: false,
        lastSync: null,
        syncInProgress: false,
        error: error.message
      });
      
      toast({
        title: "‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Cal.com ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
        description: error.message,
        variant: "destructive"
      });
      
      return { success: false, error: error.message };
    } finally {
      setLoading(false);
    }
  }, [toast]);

  /**
   * Load courses from Cal.com system
   */
  const loadCourses = useCallback(async () => {
    try {
      const result = await calcomSchedulingService.getCourses();
      
      if (result.success) {
        setCourses(result.data);
        console.log(`üìö Loaded ${result.data.length} Cal.com courses`);
      } else {
        console.error('‚ùå Failed to load courses:', result.error);
        setCourses([]);
      }
      
      return result;
    } catch (error) {
      console.error('üí• Exception loading courses:', error);
      setCourses([]);
      return { success: false, error: error.message };
    }
  }, []);

  /**
   * Load instructors
   */
  const loadInstructors = useCallback(async () => {
    try {
      const result = await calcomSchedulingService.getInstructors();
      
      if (result.success) {
        setInstructors(result.data);
        console.log(`üë®‚Äçüè´ Loaded ${result.data.length} instructors`);
      } else {
        console.error('‚ùå Failed to load instructors:', result.error);
        setInstructors([]);
      }
      
      return result;
    } catch (error) {
      console.error('üí• Exception loading instructors:', error);
      setInstructors([]);
      return { success: false, error: error.message };
    }
  }, []);

  /**
   * Load schedules for current week
   */
  const loadSchedules = useCallback(async () => {
    if (!isInitialized) return;
    
    setLoading(true);
    setError(null);
    
    try {
      console.log('üìÖ Loading Cal.com schedules for week:', weekStartDate);
      
      const result = await calcomSchedulingService.getWeekSchedules(weekStartDate, company);
      
      if (result.success) {
        setSchedules(result.data);
        console.log(`‚úÖ Loaded ${Object.keys(result.data).length} schedules`);
      } else {
        console.error('‚ùå Failed to load schedules:', result.error);
        setError(result.error);
        
        toast({
          title: "‡πÇ‡∏´‡∏•‡∏î‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
          description: result.error,
          variant: "destructive"
        });
      }
      
      return result;
    } catch (err) {
      console.error('üí• Exception loading schedules:', err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [isInitialized, company, toast, weekStartDate]);

  /**
   * Add new schedule
   */
  const addSchedule = useCallback(async (dayIndex, timeIndex, scheduleData) => {
    if (!isInitialized) {
      toast({
        title: "‡∏£‡∏∞‡∏ö‡∏ö‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°",
        description: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö",
        variant: "warning"
      });
      return { success: false, error: 'System not initialized' };
    }

    const scheduleKey = `${dayIndex}-${timeIndex}`;
    
    // Optimistic update
    const optimisticSchedule = {
      id: `temp-${Date.now()}`,
      dayIndex,
      timeIndex,
      course: scheduleData.course,
      instructor: scheduleData.instructor,
      instructor_id: scheduleData.instructor_id,
      company: scheduleData.company,
      room: scheduleData.room,
      isOptimistic: true,
      provider: 'calcom'
    };

    setSchedules(prev => ({
      ...prev,
      [scheduleKey]: optimisticSchedule
    }));

    try {
      console.log('üíæ Adding Cal.com schedule:', { dayIndex, timeIndex, scheduleData });
      
      const result = await calcomSchedulingService.addSchedule(
        dayIndex, 
        timeIndex, 
        scheduleData, 
        weekStartDate
      );

      if (result.success) {
        console.log('‚úÖ Cal.com schedule added successfully');
        
        // Replace optimistic with real data
        setSchedules(prev => {
          const newSchedules = { ...prev };
          newSchedules[scheduleKey] = {
            id: result.data.localBooking?.id || result.data.calcomBooking.id,
            dayIndex,
            timeIndex,
            course: scheduleData.course,
            instructor: scheduleData.instructor,
            instructor_id: scheduleData.instructor_id,
            company: scheduleData.company,
            room: scheduleData.room,
            provider: 'calcom',
            calcomId: result.data.calcomBooking.id
          };
          return newSchedules;
        });
        
        toast({
          title: "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
          description: `‡πÄ‡∏û‡∏¥‡πà‡∏° ${scheduleData.course?.name || scheduleData.courseName} ‡πÅ‡∏•‡πâ‡∏ß (Cal.com)`,
          variant: "default"
        });
        
        return { success: true, data: result.data };
      } else {
        // Revert optimistic update
        setSchedules(prev => {
          const newSchedules = { ...prev };
          delete newSchedules[scheduleKey];
          return newSchedules;
        });
        
        console.error('‚ùå Failed to add Cal.com schedule:', result.error);
        
        toast({
          title: "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
          description: result.error,
          variant: "destructive"
        });
        
        return result;
      }
    } catch (err) {
      console.error('üí• Exception adding schedule:', err);
      
      // Revert optimistic update
      setSchedules(prev => {
        const newSchedules = { ...prev };
        delete newSchedules[scheduleKey];
        return newSchedules;
      });
      
      toast({
        title: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î",
        description: "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÑ‡∏î‡πâ",
        variant: "destructive"
      });
      
      return { success: false, error: err.message };
    }
  }, [isInitialized, weekStartDate, toast]);

  /**
   * Remove schedule
   */
  const removeSchedule = useCallback(async (dayIndex, timeIndex) => {
    if (!isInitialized) return { success: false, error: 'System not initialized' };

    const scheduleKey = `${dayIndex}-${timeIndex}`;
    const originalSchedule = schedules[scheduleKey];

    if (!originalSchedule) {
      console.log('‚ö†Ô∏è No schedule to remove at:', { dayIndex, timeIndex });
      return { success: true };
    }

    // Optimistic update
    setSchedules(prev => {
      const newSchedules = { ...prev };
      delete newSchedules[scheduleKey];
      return newSchedules;
    });

    try {
      console.log('üóëÔ∏è Removing Cal.com schedule:', { dayIndex, timeIndex });
      
      const result = await calcomSchedulingService.removeSchedule(dayIndex, timeIndex, weekStartDate);

      if (result.success) {
        console.log('‚úÖ Cal.com schedule removed successfully');
        
        toast({
          title: "‡∏•‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
          description: `‡∏•‡∏ö ${originalSchedule.course?.name || '‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£'} ‡πÅ‡∏•‡πâ‡∏ß (Cal.com)`,
          variant: "default"
        });
        
        return { success: true };
      } else {
        // Revert optimistic update
        setSchedules(prev => ({
          ...prev,
          [scheduleKey]: originalSchedule
        }));
        
        console.error('‚ùå Failed to remove Cal.com schedule:', result.error);
        
        toast({
          title: "‡∏•‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
          description: result.error,
          variant: "destructive"
        });
        
        return result;
      }
    } catch (err) {
      console.error('üí• Exception removing schedule:', err);
      
      // Revert optimistic update
      setSchedules(prev => ({
        ...prev,
        [scheduleKey]: originalSchedule
      }));
      
      toast({
        title: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î",
        description: "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÑ‡∏î‡πâ",
        variant: "destructive"
      });
      
      return { success: false, error: err.message };
    }
  }, [isInitialized, weekStartDate, schedules, toast]);

  /**
   * Create new course
   */
  const createCourse = useCallback(async (courseData) => {
    try {
      console.log('üÜï Creating new Cal.com course:', courseData.name);
      
      const result = await calcomSchedulingService.createCourse(courseData);
      
      if (result.success) {
        console.log('‚úÖ Course created successfully');
        
        // Reload courses
        await loadCourses();
        
        toast({
          title: "‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏≠‡∏£‡πå‡∏™‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
          description: `‡∏™‡∏£‡πâ‡∏≤‡∏á ${courseData.name} ‡πÅ‡∏•‡πâ‡∏ß`,
          variant: "default"
        });
        
        return result;
      } else {
        console.error('‚ùå Failed to create course:', result.error);
        
        toast({
          title: "‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏≠‡∏£‡πå‡∏™‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
          description: result.error,
          variant: "destructive"
        });
        
        return result;
      }
    } catch (error) {
      console.error('üí• Exception creating course:', error);
      
      toast({
        title: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î",
        description: "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏≠‡∏£‡πå‡∏™‡πÑ‡∏î‡πâ",
        variant: "destructive"
      });
      
      return { success: false, error: error.message };
    }
  }, [loadCourses, toast]);

  /**
   * Create new instructor
   */
  const createInstructor = useCallback(async (instructorData) => {
    try {
      console.log('üÜï Creating new instructor:', instructorData.name);
      
      const result = await calcomSchedulingService.createInstructor(instructorData);
      
      if (result.success) {
        console.log('‚úÖ Instructor created successfully');
        
        // Reload instructors
        await loadInstructors();
        
        toast({
          title: "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ú‡∏π‡πâ‡∏™‡∏≠‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
          description: `‡πÄ‡∏û‡∏¥‡πà‡∏° ${instructorData.name} ‡πÅ‡∏•‡πâ‡∏ß`,
          variant: "default"
        });
        
        return result;
      } else {
        console.error('‚ùå Failed to create instructor:', result.error);
        
        toast({
          title: "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ú‡∏π‡πâ‡∏™‡∏≠‡∏ô‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
          description: result.error,
          variant: "destructive"
        });
        
        return result;
      }
    } catch (error) {
      console.error('üí• Exception creating instructor:', error);
      
      toast({
        title: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î",
        description: "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ú‡∏π‡πâ‡∏™‡∏≠‡∏ô‡πÑ‡∏î‡πâ",
        variant: "destructive"
      });
      
      return { success: false, error: error.message };
    }
  }, [loadInstructors, toast]);

  /**
   * Update schedule duration
   */
  const updateScheduleDuration = useCallback(async (scheduleId, newDurationMinutes) => {
    try {
      console.log('üîÑ Updating schedule duration:', { scheduleId, newDurationMinutes });
      
      const result = await calcomSchedulingService.updateScheduleDuration(scheduleId, newDurationMinutes);
      
      if (result.success) {
        console.log('‚úÖ Schedule duration updated successfully');
        
        // Reload schedules to reflect changes
        await loadSchedules();
        
        toast({
          title: "‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
          description: `‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏õ‡πá‡∏ô ${Math.round(newDurationMinutes / 60)} ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á`,
          variant: "default"
        });
        
        return result;
      } else {
        console.error('‚ùå Failed to update schedule duration:', result.error);
        
        toast({
          title: "‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
          description: result.error,
          variant: "destructive"
        });
        
        return result;
      }
    } catch (error) {
      console.error('üí• Exception updating schedule duration:', error);
      
      toast({
        title: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î",
        description: "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÑ‡∏î‡πâ",
        variant: "destructive"
      });
      
      return { success: false, error: error.message };
    }
  }, [loadSchedules, toast]);

  /**
   * Manual sync with Cal.com
   */
  const syncWithCalcom = useCallback(async () => {
    try {
      setCalcomStatus(prev => ({ ...prev, syncInProgress: true }));
      console.log('üîÑ Manual sync with Cal.com requested');
      
      const result = await calcomSchedulingService.syncFromCalcom(weekStartDate);
      
      if (result.success) {
        console.log('‚úÖ Sync completed successfully');
        
        // Reload data
        await Promise.all([
          loadSchedules(),
          loadCourses()
        ]);
        
        setCalcomStatus(prev => ({ 
          ...prev, 
          lastSync: new Date().toISOString(),
          syncInProgress: false 
        }));
        
        toast({
          title: "‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
          description: "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏™‡∏≠‡∏ô‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡πÅ‡∏•‡πâ‡∏ß",
          variant: "default"
        });
        
        return result;
      } else {
        console.error('‚ùå Sync failed:', result.error);
        
        toast({
          title: "‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
          description: result.error,
          variant: "destructive"
        });
        
        return result;
      }
    } catch (error) {
      console.error('üí• Sync exception:', error);
      
      toast({
        title: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ã‡∏¥‡∏á‡∏Ñ‡πå",
        description: error.message,
        variant: "destructive"
      });
      
      return { success: false, error: error.message };
    } finally {
      setCalcomStatus(prev => ({ ...prev, syncInProgress: false }));
    }
  }, [weekStartDate, loadSchedules, loadCourses, toast]);

  /**
   * Load sync logs
   */
  const loadSyncLogs = useCallback(async (limit = 20) => {
    try {
      const result = await calcomSchedulingService.getSyncLogs(limit);
      if (result.success) {
        setSyncLogs(result.data);
      }
      return result;
    } catch (error) {
      console.error('Error loading sync logs:', error);
      return { success: false, error: error.message };
    }
  }, []);

  /**
   * Get schedule at specific position
   */
  const getSchedule = useCallback((dayIndex, timeIndex) => {
    const scheduleKey = `${dayIndex}-${timeIndex}`;
    return schedules[scheduleKey] || null;
  }, [schedules]);

  /**
   * Check if schedule exists
   */
  const hasSchedule = useCallback((dayIndex, timeIndex) => {
    return getSchedule(dayIndex, timeIndex) !== null;
  }, [getSchedule]);

  /**
   * Get all schedules for a specific day
   */
  const getDaySchedules = useCallback((dayIndex) => {
    return calcomSchedulingService.TIME_SLOTS.map((timeSlot, timeIndex) => ({
      timeIndex,
      timeSlot,
      schedule: getSchedule(dayIndex, timeIndex)
    }));
  }, [getSchedule]);

  // Initialize system when component mounts
  useEffect(() => {
    if (!isInitialized) {
      initializeSystem();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Load courses and instructors when system is initialized
  useEffect(() => {
    if (isInitialized) {
      loadCourses();
      loadInstructors();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isInitialized]);

  // Load schedules when week or system changes
  useEffect(() => {
    if (isInitialized && weekStartDate) {
      loadSchedules();
    }
    currentWeekRef.current = currentWeek;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [weekStartDate, isInitialized]);

  return {
    // Data
    schedules,
    courses,
    instructors,
    syncLogs,
    loading,
    error,
    isInitialized,
    calcomStatus,
    weekStartDate,
    
    // Schedule operations
    addSchedule,
    removeSchedule,
    updateScheduleDuration,
    getSchedule,
    hasSchedule,
    getDaySchedules,
    
    // Course operations
    createCourse,
    loadCourses,
    
    // Instructor operations
    loadInstructors,
    createInstructor,
    
    // System operations
    initializeSystem,
    loadSchedules,
    syncWithCalcom,
    loadSyncLogs,
    
    // Constants
    TIME_SLOTS: calcomSchedulingService.TIME_SLOTS,
    DAYS: calcomSchedulingService.DAYS,
    
    // Stats
    totalSchedules: Object.keys(schedules).length,
    hasData: Object.keys(schedules).length > 0,
    totalCourses: courses.length,
    totalInstructors: instructors.length
  };
};

export default useCalcomSchedule;